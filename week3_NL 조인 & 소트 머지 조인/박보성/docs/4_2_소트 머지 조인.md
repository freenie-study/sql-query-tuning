소트 머지 조인
-

- 조인 컬럼에 인덱스가 없거나, 대량 데이터 조인인 경우 소트 머지조인 또는 해시조인을 사용한다.
- 소트 머지 조인은 해시 조인보다는 못하지만 해시 조인을 사용할 수 없는 상황에 유용하다.

SGA, PGA
-
- SGA
  - 공유 메모리 영역인 SGA는 여러 프로세스가 공유할 수 있지만, 동시에 액세스 할 수는 없다.
  - 동시에 액세스하는 프로세스간 약새스를 직렬화하기 위한 Lock 매커니즘으로 래치가 존재한다.
  - DB 버퍼 캐시 역시 SGA의 구성요소이며 역시 Lock을 획득해야 한다.
- PGA
  - 오라클 서버 프로세스는 SGA에 공유된 데이터를 읽으며, 동시의 자신의 고유한 메모리 영역을 가진다.
  - 각 오라클 서버 프로세스에 할당된 메모리 영역을 PGA(Process/Program/Private Global Area)라고 한다.
  - 프로세스에 종속적인 고유 데이터를 저장하며, 공간이 부족할 때에는 Temp 테이블 스페이스를 할당받는다.
  - 다른 프로세스와 공유하지 않는 독립적인 메모리 공간이므로 래치 메커니즘이 불필요하다. 따라서 같은 양의 데이터를 읽더라도 SGA 버퍼캐시에서 읽을 때 보다 훨씬 빠르다.

소트 머지 조인 기본 매커니즘
-
- 이름이 의미하는 바와 같이 두 단계로 진행된다
  - 소트 단계: 양쪽 집합을 조인 컬럼 기준으로 정렬한다.
  - 머지 단계: 정렬한 양쪽 집합을 머지한다.
- 실제 오퍼레이션을 담당하는 머지단계는 Nested Loop 방식으로 NL 조인과 크게 다르지 않다.
- 다만 Outer 테이블을 기준으로 매번 Full Scan 하지 않아도 되며, 데이터가 항상 정렬되어 있으므로, 조인 대상 레코드의 시작점과 끝점을 쉽게 알 수 있다.
- Sort Area에 저장된 데이터 자체가 인덱스의 역할을 하므로 조인컬럼에 인덱스 유무와 상관없이 가능하다.

소트 머지 조인이 빠른 이유
-
- NL 조인은 DB 버퍼 캐시와 디스크를 번번히, 일일히 경유해야 한다.
- 반면 소트 머지조인은 양쪽 테이블로 부터 데이터를 일괄적으로 읽어들여, PGA에 저장한 후 조인한다,
- 또 PGA는 독립적인 메모리 공간이므로 래치 획득과정이 없다.
- 물로 소트 머지 조인도 양 쪽 테이블로 부터 조인 대상 집합을 읽을 때에는 DB버퍼 캐시를 경유한다. 이 때 인덱스를 이용하기도 하며, 과정에서 버퍼캐시 탐색비용과 랜덤 액세스 부담이 생기기도 한다.

소트 머지 조인의 주용도
-
- 해시조인은 조인조건식이 등치조건이 아니라면 사용할 수 없다.
- 따라서 해시조인보다 성능은 떨어지지만, 소트머지조인은 다음과 같은 상황에 사용된다.
  1. 조인 조건식이 등치조건이 아닌 대량 데이터 조인
  2. 조인 조건식이 아예 없는 조인(카테시안 곱)
  3. 조인 인덱스가 없는 상황에서, 두 테이블을 각각 읽어 조인대상 집합을 줄일 수 있는 경우
